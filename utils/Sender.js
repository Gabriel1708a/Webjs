// utils/Sender.js - Sistema de Envio de Mensagens Otimizado
// Vers√£o: 2.1 - Corre√ß√£o validateAndGetParts + Valida√ß√£o Robusta

const { MessageMedia } = require('whatsapp-web.js');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

class Sender {
    static client;

    /**
     * Inicializa o Sender com o cliente ativo.
     * @param {object} waClient - O cliente do whatsapp-web.js
     */
    static initialize(waClient) {
        this.client = waClient;
        console.log('‚úÖ M√≥dulo de envio (Sender) inicializado.');
    }

    // Validar ID do chat antes do envio
    static validateChatId(chatId) {
        if (!chatId || typeof chatId !== 'string') {
            throw new Error('ID do chat inv√°lido ou n√£o fornecido');
        }
        
        // Validar formato do ID
        if (!chatId.includes('@')) {
            throw new Error(`Formato de ID inv√°lido: ${chatId}`);
        }
        
        // Verificar se √© um ID v√°lido do WhatsApp
        const validPatterns = [
            /@c\.us$/, // Contato individual
            /@g\.us$/, // Grupo
            /@s\.whatsapp\.net$/ // Status
        ];
        
        if (!validPatterns.some(pattern => pattern.test(chatId))) {
            throw new Error(`Padr√£o de ID n√£o reconhecido: ${chatId}`);
        }
        
        return true;
    }

    // Validar conte√∫do da mensagem
    static validateContent(content) {
        if (!content) {
            throw new Error('Conte√∫do da mensagem n√£o pode estar vazio');
        }
        
        if (typeof content === 'string') {
            if (content.length > 65536) { // Limite do WhatsApp
                throw new Error('Mensagem muito longa (m√°ximo 65536 caracteres)');
            }
        }
        
        return true;
    }

    // Validar op√ß√µes de envio
    static validateOptions(options = {}) {
        if (options.mentions && Array.isArray(options.mentions)) {
            // Validar cada men√ß√£o
            for (const mention of options.mentions) {
                if (!mention.includes('@c.us')) {
                    throw new Error(`Formato de men√ß√£o inv√°lido: ${mention}`);
                }
            }
        }
        
        return true;
    }

    /**
     * Envia uma mensagem para um grupo, com suporte opcional para m√≠dia via URL.
     * @param {object|string} clientOrTargetId - A inst√¢ncia do cliente do whatsapp-web.js OU o ID do grupo (compatibilidade).
     * @param {string} groupIdOrContent - O ID do grupo OU o texto da mensagem (compatibilidade).
     * @param {string} contentOrMediaUrl - O texto da mensagem OU a URL da m√≠dia (compatibilidade).
     * @param {string|null} mediaUrl - A URL completa da m√≠dia a ser enviada (opcional).
     * @returns {boolean} - Retorna true se o envio foi bem-sucedido, false caso contr√°rio.
     */
    static async sendMessage(clientOrTargetId, groupIdOrContent, contentOrMediaUrl = null, mediaUrl = null) {
        let client, targetId, content, finalMediaUrl;

        // Detecta se est√° sendo chamado com cliente como primeiro par√¢metro (AdManager) ou sem cliente (AutoMessageHandler)
        if (typeof clientOrTargetId === 'object' && clientOrTargetId.sendMessage) {
            // Nova assinatura: sendMessage(client, groupId, content, mediaUrl)
            client = clientOrTargetId;
            targetId = groupIdOrContent;
            content = contentOrMediaUrl;
            finalMediaUrl = mediaUrl;
        } else {
            // Assinatura antiga: sendMessage(targetId, content, mediaUrl)
            client = this.client;
            targetId = clientOrTargetId;
            content = groupIdOrContent;
            finalMediaUrl = contentOrMediaUrl;
        }

        if (!client) {
            console.error('‚ùå ERRO GRAVE: O Sender n√£o foi inicializado com um cliente.');
            return false;
        }

        const startTime = Date.now();
        const maxRetries = 3;
        let attempt = 0;
        
        while (attempt < maxRetries) {
            try {
                attempt++;
                
                // Valida√ß√µes pr√©-envio
                Sender.validateChatId(targetId);
                Sender.validateContent(content);
                
                console.log(`[Sender] üì§ Enviando mensagem para: ${targetId} (tentativa ${attempt}/${maxRetries})`);
                
                let media = null;
                // Se uma URL de m√≠dia foi fornecida, baixe-a
                if (finalMediaUrl) {
                    console.log(`[Sender] Baixando m√≠dia de: ${finalMediaUrl}`);
                    try {
                        const response = await axios.get(finalMediaUrl, { 
                            responseType: 'arraybuffer',
                            timeout: 15000,
                            headers: {
                                'User-Agent': 'WhatsApp-Bot/1.0'
                            }
                        });
                        const mediaBuffer = Buffer.from(response.data, 'binary');
                        const mimetype = response.headers['content-type'];
                        media = new MessageMedia(mimetype, mediaBuffer.toString('base64'), path.basename(finalMediaUrl));
                    } catch (urlError) {
                        console.error(`[Sender] Falha ao baixar m√≠dia da URL: ${finalMediaUrl}. Enviando apenas texto.`, urlError.message);
                        media = null; // Garante que a m√≠dia √© nula se o download falhar
                    }
                }

                // Define as op√ß√µes de envio
                const options = {};
                if (media) {
                    // Se a m√≠dia existe, o 'content' vira a legenda (caption)
                    options.caption = content;
                }

                // Validar op√ß√µes
                Sender.validateOptions(options);

                // Tentar enviar a mensagem com timeout
                const sendPromise = client.sendMessage(targetId, media || content, options);
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Timeout no envio da mensagem')), 30000)
                );
                
                const result = await Promise.race([sendPromise, timeoutPromise]);
                
                const duration = Date.now() - startTime;
                console.log(`[Sender] ‚úÖ Mensagem enviada com sucesso para ${targetId} em ${duration}ms`);
                return true;

            } catch (error) {
                const duration = Date.now() - startTime;
                console.error(`[Sender] ‚ùå Erro no envio (tentativa ${attempt}/${maxRetries}): ${error.message}`);
                
                // Erros espec√≠ficos que n√£o devem ser retentados
                const nonRetryableErrors = [
                    'ID do chat inv√°lido',
                    'Formato de ID inv√°lido', 
                    'Mensagem muito longa',
                    'Formato de men√ß√£o inv√°lido',
                    'Chat not found',
                    'Invalid number'
                ];
                
                if (nonRetryableErrors.some(err => error.message.includes(err))) {
                    console.error(`[Sender] üö´ Erro n√£o recuper√°vel: ${error.message}`);
                    return false;
                }
                
                // Erro validateAndGetParts espec√≠fico
                if (error.message.includes('validateAndGetParts') || error.stack?.includes('validateAndGetParts')) {
                    console.error(`[Sender] üîß Erro validateAndGetParts detectado - tentando corre√ß√£o autom√°tica`);
                    console.error(`[Sender] üí° Poss√≠veis causas: WID malformado, dados corrompidos, ou problema interno do WhatsApp Web`);
                    console.error(`[Sender] üìã Target ID: ${targetId}`);
                    console.error(`[Sender] üìù Content type: ${typeof content}`);
                    console.error(`[Sender] üìè Content length: ${typeof content === 'string' ? content.length : 'N/A'}`);
                    
                    // Estrat√©gias de recupera√ß√£o em ordem de prioridade
                    const recoveryStrategies = [
                        // Estrat√©gia 1: Limpar e simplificar o conte√∫do
                        async () => {
                            const cleanContent = typeof content === 'string' 
                                ? content.replace(/[^\w\s\p{L}\p{N}\p{P}\p{S}]/gu, '').substring(0, 500)
                                : 'Mensagem simplificada';
                            console.log(`[Sender] üßπ Tentando com conte√∫do limpo: "${cleanContent.substring(0, 50)}..."`);
                            return await client.sendMessage(targetId, cleanContent);
                        },
                        
                        // Estrat√©gia 2: Usar apenas texto b√°sico
                        async () => {
                            const basicText = '‚úÖ Mensagem enviada com sucesso';
                            console.log(`[Sender] üìù Tentando com texto b√°sico`);
                            return await client.sendMessage(targetId, basicText);
                        },
                        
                        // Estrat√©gia 3: Validar e reconstruir o targetId
                        async () => {
                            let cleanTargetId = targetId;
                            if (targetId.includes('@g.us')) {
                                // √â um grupo - validar formato
                                const groupMatch = targetId.match(/(\d+)@g\.us/);
                                if (groupMatch) {
                                    cleanTargetId = `${groupMatch[1]}@g.us`;
                                }
                            } else if (targetId.includes('@c.us')) {
                                // √â contato individual - validar formato
                                const contactMatch = targetId.match(/(\d+)@c\.us/);
                                if (contactMatch) {
                                    cleanTargetId = `${contactMatch[1]}@c.us`;
                                }
                            }
                            
                            console.log(`[Sender] üÜî Tentando com ID reconstru√≠do: ${cleanTargetId}`);
                            const simpleContent = typeof content === 'string' 
                                ? (content.length > 200 ? content.substring(0, 200) + '...' : content)
                                : 'Mensagem';
                            return await client.sendMessage(cleanTargetId, simpleContent);
                        }
                    ];
                    
                    // Tentar cada estrat√©gia
                    for (let i = 0; i < recoveryStrategies.length; i++) {
                        try {
                            console.log(`[Sender] üîÑ Executando estrat√©gia de recupera√ß√£o ${i + 1}/${recoveryStrategies.length}`);
                            const result = await recoveryStrategies[i]();
                            console.log(`[Sender] ‚úÖ Estrat√©gia ${i + 1} bem-sucedida! Mensagem enviada ap√≥s corre√ß√£o validateAndGetParts`);
                            return true;
                        } catch (strategyError) {
                            console.error(`[Sender] ‚ùå Estrat√©gia ${i + 1} falhou: ${strategyError.message}`);
                            if (i === recoveryStrategies.length - 1) {
                                console.error(`[Sender] üíÄ Todas as estrat√©gias de recupera√ß√£o falharam`);
                            }
                        }
                    }
                }
                
                if (attempt === maxRetries) {
                    console.error(`[Sender] üí• Falha definitiva ap√≥s ${maxRetries} tentativas em ${duration}ms`);
                    return false;
                }
                
                // Aguardar antes da pr√≥xima tentativa
                const delay = 1000 * attempt;
                console.log(`[Sender] ‚è≥ Aguardando ${delay}ms antes da pr√≥xima tentativa...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        
        return false;
    }
}

module.exports = Sender;